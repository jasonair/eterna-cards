import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseClient';
import { deleteProductAndInventory } from '@/lib/db';

// GET product + inventory + transit history for /inventory/[productId]
export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const id = url.searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'Product id is required' },
        { status: 400 }
      );
    }

    // 1) Load the product row first
    const { data: productRow, error: productError } = await supabase
      .from('products')
      .select('*')
      .eq('id', id)
      .single();

    if (productError || !productRow) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    // 2) Load related entities in parallel
    const [inventoryRes, supplierRes, transitRes, poLinesRes, purchaseOrdersRes, invoicesRes] =
      await Promise.all([
        supabase.from('inventory').select('*').eq('productid', id),
        productRow.supplierid
          ? supabase.from('suppliers').select('*').eq('id', productRow.supplierid).single()
          : Promise.resolve({ data: null } as any),
        supabase.from('transit').select('*').eq('productid', id),
        supabase.from('polines').select('*'),
        supabase.from('purchaseorders').select('*'),
        supabase.from('invoices').select('*'),
      ]);

    const inventoryRows = inventoryRes.data || [];
    const supplierRow = (supplierRes as any).data || null;
    const transitRows = transitRes.data || [];
    const poLineRows = poLinesRes.data || [];
    const poRows = purchaseOrdersRes.data || [];
    const invoiceRows = invoicesRes.data || [];

    // Map product to camelCase DTO
    const product = {
      id: productRow.id,
      name: productRow.name,
      primarySku: productRow.primarysku ?? null,
      supplierSku: productRow.suppliersku ?? null,
      barcodes: productRow.barcodes ?? [],
      aliases: productRow.aliases ?? [],
      supplierId: productRow.supplierid ?? null,
      category: productRow.category ?? null,
      tags: productRow.tags ?? [],
      imageUrl: productRow.imageurl ?? null,
      createdAt: productRow.created_at,
      updatedAt: productRow.updated_at,
    };

    let inventory =
      inventoryRows[0]
        ? {
            id: inventoryRows[0].id,
            productId: inventoryRows[0].productid,
            quantityOnHand: Number(inventoryRows[0].quantityonhand ?? 0),
            averageCostGBP: Number(inventoryRows[0].averagecostgbp ?? 0),
            lastUpdated: inventoryRows[0].lastupdated,
          }
        : null;

    const supplier = supplierRow
      ? {
          id: supplierRow.id,
          name: supplierRow.name,
          address: supplierRow.address ?? null,
          email: supplierRow.email ?? null,
          phone: supplierRow.phone ?? null,
          vatNumber: null,
          createdAt: supplierRow.created_at,
        }
      : null;

    const poLinesById = new Map(
      poLineRows.map((l: any) => [
        l.id,
        {
          id: l.id,
          purchaseOrderId: l.purchaseorderid,
          description: l.description,
          supplierSku: l.suppliersku ?? null,
          quantity: Number(l.quantity ?? 0),
          unitCostExVAT: Number(l.unitcostexvat ?? 0),
          lineTotalExVAT: Number(l.linetotalexvat ?? 0),
        },
      ])
    );

    const posById = new Map(
      poRows.map((po: any) => [
        po.id,
        {
          id: po.id,
          supplierId: po.supplierid,
          invoiceNumber: po.invoicenumber ?? null,
          invoiceDate: po.invoicedate ?? null,
          currency: po.currency,
          paymentTerms: po.paymentterms ?? null,
          createdAt: po.created_at,
        },
      ])
    );

    const invoicesByPoId = new Map(
      invoiceRows.map((inv: any) => [
        inv.purchaseorderid,
        {
          id: inv.id,
          purchaseOrderId: inv.purchaseorderid,
          supplierId: inv.supplierid,
          invoiceNumber: inv.invoicenumber ?? null,
          invoiceDate: inv.invoicedate ?? null,
          currency: inv.currency,
          createdAt: inv.created_at,
        },
      ])
    );

    const transit = transitRows
      .slice()
      .sort(
        (a: any, b: any) =>
          new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      )
      .map((t: any) => {
        const transitRecord = {
          id: t.id,
          productId: t.productid,
          purchaseOrderId: t.purchaseorderid,
          poLineId: t.polineid,
          supplierId: t.supplierid,
          quantity: Number(t.quantity ?? 0),
          remainingQuantity: Number(t.remainingquantity ?? 0),
          unitCostGBP: Number(t.unitcostgbp ?? 0),
          status: t.status,
          createdAt: t.created_at,
          updatedAt: t.updated_at,
        };

        const po = posById.get(t.purchaseorderid) || null;
        const poLine = poLinesById.get(t.polineid) || null;
        const invoice = po ? invoicesByPoId.get(po.id) || null : null;

        return {
          transit: transitRecord,
          poLine,
          purchaseOrder: po,
          invoice,
        };
      });

    // Derive an expected average unit cost from on-hand + current POs (transit)
    const remainingTransit = transitRows.filter(
      (t: any) => Number(t.remainingquantity ?? 0) > 0,
    );

    const onHandQty = inventory ? inventory.quantityOnHand : 0;
    const onHandAvg = inventory ? inventory.averageCostGBP : 0;
    let blendedTotalQty = onHandQty;
    let blendedTotalCost = onHandQty * onHandAvg;

    if (remainingTransit.length > 0) {
      for (const t of remainingTransit) {
        const qty = Number(t.remainingquantity ?? 0);
        if (!Number.isFinite(qty) || qty <= 0) continue;

        const poLine = poLinesById.get(t.polineid) || null;

        let rawUnitCost = Number(t.unitcostgbp ?? 0);
        if (!Number.isFinite(rawUnitCost) || rawUnitCost <= 0) {
          rawUnitCost = Number(
            poLine && typeof poLine.unitCostExVAT === 'number'
              ? poLine.unitCostExVAT
              : 0,
          );
        }

        const unitCost = Number.isFinite(rawUnitCost) && rawUnitCost >= 0 ? rawUnitCost : 0;

        blendedTotalQty += qty;
        blendedTotalCost += qty * unitCost;
      }
    }

    let displayAverageCost = inventory ? inventory.averageCostGBP : 0;
    if (blendedTotalQty > 0 && blendedTotalCost > 0) {
      displayAverageCost = Number((blendedTotalCost / blendedTotalQty).toFixed(4));
    }

    if (inventory) {
      inventory = { ...inventory, averageCostGBP: displayAverageCost };
    } else if (displayAverageCost > 0) {
      inventory = {
        id: product.id,
        productId: product.id,
        quantityOnHand: 0,
        averageCostGBP: displayAverageCost,
        lastUpdated: product.updatedAt || product.createdAt,
      } as any;
    }

    return NextResponse.json({
      success: true,
      data: {
        product,
        inventory,
        supplier,
        transit,
      },
    });
  } catch (error) {
    console.error('Get product history error:', error);
    return NextResponse.json(
      { error: 'Failed to load product history' },
      { status: 500 }
    );
  }
}

// Update product metadata (name, SKUs, category, tags, barcodes)
export async function PUT(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const id = url.searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'Product id is required' },
        { status: 400 }
      );
    }

    const body = await request.json();

    const updates: any = {};

    if (typeof body.name === 'string') {
      const name = body.name.trim();
      if (name.length === 0) {
        return NextResponse.json(
          { error: 'Name cannot be empty' },
          { status: 400 }
        );
      }
      updates.name = name;
    }

    if ('primarySku' in body) {
      const raw = body.primarySku;
      const value = typeof raw === 'string' ? raw.trim() : '';
      updates.primarysku = value.length > 0 ? value : null;
    }

    if ('supplierSku' in body) {
      const raw = body.supplierSku;
      const value = typeof raw === 'string' ? raw.trim() : '';
      updates.suppliersku = value.length > 0 ? value : null;
    }

    if ('category' in body) {
      const raw = body.category;
      const value = typeof raw === 'string' ? raw.trim() : '';
      updates.category = value.length > 0 ? value : null;
    }

    if (Array.isArray(body.barcodes)) {
      updates.barcodes = body.barcodes;
    }

    if (Array.isArray(body.tags)) {
      updates.tags = body.tags;
    }

    if (Array.isArray(body.aliases)) {
      updates.aliases = body.aliases;
    }

    if ('imageUrl' in body) {
      const raw = body.imageUrl;
      const value = typeof raw === 'string' ? raw.trim() : '';
      updates.imageurl = value.length > 0 ? value : null;
    }

    if (Object.keys(updates).length === 0) {
      return NextResponse.json(
        { error: 'No valid fields provided for update' },
        { status: 400 }
      );
    }

    updates.updated_at = new Date().toISOString();

    const { data: updatedRow, error } = await supabase
      .from('products')
      .update(updates)
      .eq('id', id)
      .select('*')
      .single();

    if (error || !updatedRow) {
      console.error('Update product error:', error);
      return NextResponse.json(
        { error: 'Failed to update product' },
        { status: 500 }
      );
    }

    const product = {
      id: updatedRow.id,
      name: updatedRow.name,
      primarySku: updatedRow.primarysku ?? null,
      supplierSku: updatedRow.suppliersku ?? null,
      barcodes: updatedRow.barcodes ?? [],
      aliases: updatedRow.aliases ?? [],
      supplierId: updatedRow.supplierid ?? null,
      category: updatedRow.category ?? null,
      tags: updatedRow.tags ?? [],
      createdAt: updatedRow.created_at,
      updatedAt: updatedRow.updated_at,
    }
    return NextResponse.json({ success: true, data: { product } });
  } catch (error) {
    console.error('Update product error:', error);
    return NextResponse.json(
      { error: 'Failed to update product' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    const rawName = typeof body.name === 'string' ? body.name.trim() : '';
    if (!rawName) {
      return NextResponse.json(
        { error: 'Name is required' },
        { status: 400 },
      );
    }

    const normalizeOptionalString = (value: unknown): string | null => {
      if (typeof value !== 'string') return null;
      const trimmed = value.trim();
      return trimmed.length > 0 ? trimmed : null;
    };

    const toStringArray = (value: unknown): string[] => {
      if (!Array.isArray(value)) return [];
      return value
        .map((v) => (typeof v === 'string' ? v.trim() : ''))
        .filter((v) => v.length > 0);
    };

    const insertPayload: any = {
      name: rawName,
      primarysku: normalizeOptionalString(body.primarySku),
      suppliersku: normalizeOptionalString(body.supplierSku),
      barcodes: toStringArray(body.barcodes),
      aliases: toStringArray(body.aliases),
      supplierid: normalizeOptionalString(body.supplierId) || null,
      category: normalizeOptionalString(body.category),
      tags: toStringArray(body.tags),
      imageurl: normalizeOptionalString(body.imageUrl),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    const { data: newProduct, error } = await supabase
      .from('products')
      .insert(insertPayload)
      .select('*')
      .single();

    if (error || !newProduct) {
      console.error('Create product error:', error);
      return NextResponse.json(
        { error: 'Failed to create product' },
        { status: 500 },
      );
    }

    const product = {
      id: newProduct.id,
      name: newProduct.name,
      primarySku: newProduct.primarysku ?? null,
      supplierSku: newProduct.suppliersku ?? null,
      barcodes: newProduct.barcodes ?? [],
      aliases: newProduct.aliases ?? [],
      supplierId: newProduct.supplierid ?? null,
      category: newProduct.category ?? null,
      tags: newProduct.tags ?? [],
      imageUrl: newProduct.imageurl ?? null,
      createdAt: newProduct.created_at,
      updatedAt: newProduct.updated_at,
    };

    return NextResponse.json({ success: true, data: { product } });
  } catch (error) {
    console.error('Create product error:', error);
    return NextResponse.json(
      { error: 'Failed to create product' },
      { status: 500 },
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const id = url.searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'Product id is required' },
        { status: 400 }
      );
    }

    const { data: product, error: fetchError } = await supabase
      .from('products')
      .select('*')
      .eq('id', id)
      .single();

    if (fetchError || !product) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      );
    }

    const result = await deleteProductAndInventory(id);

    return NextResponse.json({
      success: true,
      message: 'Product deleted successfully',
      deleted: {
        productId: id,
        productName: product.name,
        inventoryRows: result.deletedInventoryCount,
        transitRows: result.deletedTransitCount,
      },
    });
  } catch (error) {
    console.error('Delete product error:', error);
    return NextResponse.json(
      { error: 'Failed to delete product' },
      { status: 500 }
    );
  }
}
